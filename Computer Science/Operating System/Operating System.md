1. 프로세스
	1. IPC
2. 스레드
3. 컨텍스트 스위칭
4. 메모리 가시성
5. 임계 영역
6. 비관적 락
	1. 세마포
	2. 뮤텍스
	3. 모니터
7. 생산자 소비자
8. 낙관적 락
	1. CAS
### 낙관적 락(Optimistic Lock)을 선택하는 경우:
- 데이터 충돌이 거의 발생하지 않을 것으로 예상될 때
- 읽기 작업이 쓰기 작업보다 훨씬 많은 경우
- 짧은 시간 동안의 트랜잭션 처리가 필요한 경우
- 예시: 게시판의 조회수 업데이트, 상품 재고 확인 등
### 비관적 락(Pessimistic Lock)을 선택하는 경우:
- 데이터 충돌이 자주 발생할 것으로 예상될 때
- 데이터 정합성이 매우 중요한 경우
- 트랜잭션이 오래 걸리는 경우
- 예시: 금융 거래, 좌석 예약 시스템, 재고 관리 등
### 락 프리(Lock-Free)를 선택하는 경우:
- 초고속 처리가 필요한 경우
- 메모리 수준의 동시성 제어가 필요할 때
- 시스템 레벨의 최적화가 필요한 경우
- 데드락 위험을 완전히 제거해야 하는 경우
- 예시: 고성능 캐시 시스템, 게임 서버의 실시간 데이터 처리 등
### 낙관적 락:
- 장점: 락 획득/해제 오버헤드가 없어 성능이 좋음
- 단점: 충돌 시 롤백으로 인한 비용 발생
### 비관적 락:
- 장점: 확실한 데이터 정합성 보장
- 단점: 성능 저하, 데드락 가능성
### 락 프리:
- 장점: 최고의 성능과 확장성
- 단점: 구현이 매우 복잡하고 버그 발생 가능성이 높음


- CAS 하고 낙관적 락하고 다름
- 낙관적 락 -> 조회 + CAS


# 스왑에 대해서
### 페이지 폴트 아님
- 자바는 스레드가 자바의 힙 영역 메모리(-Xmx)를 초과할 경우, OOM 발생
- 스레드는 많아져서 메모리의 크기를 넘어서면 Swap 이 발생
- 자바 자체에서는 Swap 이 발생하지 않지만, JVM 을 하나의 프로세스로 다루는 운영체제 레벨에서는 Swap 발생 가능성 있음.
- WAS는 활성 상태의 메모리를 사용하기 때문에, 스왑 대상이 되기 어려움
- 운영체제 설정 별로 Swap 이 발생하기 시작하는 시점이 다름 (40%부터~60%부터)
- 해당 값을 올리고, 그 값을 넘기지 않을 수준까지 JVM 제어
### 컨텍스트 스위칭의 핵심 오버헤드는 "캐시 미스"
- JVM의 스레드 크기는 1MB
- 근데 이걸 통째로 캐시에 올리는게 아님
- 실제로는 수KB짜리 가벼운 정보가 이동
	- 스레드가 실행하는 명령어들
	- 스레드가 접근하는 데이터
	- 스레드의 작업에 필요한 변수들
- JVM 스레드는 OS 네이티브 스레드에 1:1로 매핑됨. 
- 즉, 컨텍스트 스위칭은 실제로 OS 레벨에서 일어남.
1. 컨텍스트 스위칭 시 실제로 저장/복원되는 것:
- CPU 레지스터 상태
- 프로그램 카운터
- 스택 포인터
- 기타 하드웨어 관련 상태 정보
2. 스레드의 메모리 공간(스택 등)은
- 물리적으로 이동하지 않음
- 페이지 테이블 엔트리만 변경됨
- 실제 데이터 복사는 발생하지 않음
3. 가상 메모리 시스템 덕분에
- 스레드의 전체 메모리 공간을 물리적으로 옮길 필요가 없음
- MMU(Memory Management Unit)가 가상 주소를 물리 주소로 매핑