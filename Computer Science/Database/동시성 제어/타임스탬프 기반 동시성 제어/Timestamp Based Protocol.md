# 타임스태프 기반 프로토콜이란?
- 락을 사용하지 않는 동시성 제어 방식
- 각 트랜잭션에 고유한 타임스탬프 부여
- 타임스탬프 순서에 따라 직렬화 순서 결정

### 타임스탬프 생성 방식
1) System Clock 사용
2) Logical Counter 사용 (단조 증가하는 카운터)

# 기본 구성요소
데이터 아이템마다 유지하는 타임스탬프:
1) W-timestamp(Q): Q를 마지막으로 쓴 트랜잭션의 타임스탬프
2) R-timestamp(Q): Q를 마지막으로 읽은 트랜잭션의 타임스탬프


# 기본 동작 규칙
### 읽기 연산(Ti가 Q를 읽으려고 할 때):
1) TimeStamp(Ti) < W-timestamp(Q)인 경우
   - 이미 미래의 트랜잭션이 쓴 값을 읽으려 함
   - Ti를 롤백하고 새로운 타임스탬프로 재시작

2) TS(Ti) ≥ W-timestamp(Q)인 경우
   - 읽기 허용
   - R-timestamp(Q) = max(R-timestamp(Q), TS(Ti))

### 쓰기 연산(Ti가 Q를 쓰려고 할 때):
1) TS(Ti) < R-timestamp(Q) 또는 TS(Ti) < W-timestamp(Q)인 경우
   - 이미 미래의 트랜잭션이 읽거나 쓴 데이터를 수정하려 함
   - Ti를 롤백하고 새로운 타임스탬프로 재시작

2) 그 외의 경우
   - 쓰기 허용
   - W-timestamp(Q) = TS(Ti)

##### [[토마스의 쓰기 규칙]]


# 장점
- 데드락이 발생하지 않음 
- 락 관리 오버헤드 없음 
- 읽기 전용 트랜잭션에 효율적

# 단점
- 롤백이 자주 발생할 수 있음 
- 타임스탬프 관리 오버헤드 
- 캐시 효율성이 낮을 수 있음


# 실무 적용 시 고려사항
1) 적합한 사용 케이스
   - 읽기 작업이 많은 시스템
   - 쓰기 충돌이 적은 경우
   - 짧은 트랜잭션이 많은 경우

2) 피해야 할 케이스
   - 쓰기 작업이 많은 시스템
   - 긴 트랜잭션이 많은 경우
   - 롤백 비용이 큰 경우