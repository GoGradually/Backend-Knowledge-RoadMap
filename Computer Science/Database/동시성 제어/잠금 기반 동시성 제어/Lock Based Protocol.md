# 기본적인 락 기반 잠금의 두가지 모드
### Shared Lock (S)
- 읽기 연산만 허용
- 쓰기를 막음
- 여러 트랜잭션이 동시에 Shared Lock 가능 
### Exclusive Lock (X)
- 읽기/쓰기 모두 허용
	- 다른 트랜잭션의 읽기를 막음
	- 다른 트랜잭션의 쓰기를 막음
- 한 번에 하나의 트랜잭션만 가능

# 주요 포인트 
- 저수준의 고립성의 레벨 구현은 두가지 기능의 조화로 구현된다.
    - 작업별 락의 종류
    - 락의 해제 시점
1. Lock 획득의 중요성
	- 데이터 읽기/쓰기 전에 반드시 적절한 Lock 획득 필요
2. Lock 호환성 문제
	- S-Lock끼리는 호환됨
	- X-Lock은 다른 어떤 Lock과도 호환되지 않음
3. Lock 해제 타이밍의 중요성
	- 너무 일찍 해제하면 일관성이 깨질 수 있음
	- 너무 늦게 해제하면 동시성이 떨어짐


# 한계
### 예시
T1: A 계좌에서 B 계좌로 50 이체
T2: B 계좌에서 A 계좌로 30 이체

실행 순서:
1. T1: lock-X(A)
2. T1: read(A)
3. T1: A = A - 50
4. T1: write(A) 
5. T1: unlock(A)      // 너무 일찍 unlock
6. T2: lock-X(A)      // T2가 중간에 A를 변경
7. T2: read(A)        
8. T2: A = A + 30
9. T2: write(A)
...

### 문제점 
- T1의 작업이 완전히 끝나기 전에 T2가 A값을 읽고 수정
- 직렬화 가능한(Serializable) 스케줄이 보장되지 않음
- 이런 상황을 막으려면 모든 락을 끝까지 유지해야 함 -> 동시성 매우 저하
- 해결 방법 - [[2PL]]