- 어떠한 인터페이스를 클라이언트가 요구하는 대로 적응시키기 위한 패턴
- 예시 소스코드
    ```java
    public class TerkeyAdapter implements Duck{
    	Turkey turkey //어댑티 인터페이스를 구성으로 갖고 있음
    	
    	// 구성할 객체 주입받음
    	public TurkeyAdapter (Turkey turkey){ 
    		this.turkey = turkey;
    	}
    	
    	// Duck 의 인터페이스에 들어있는 메소드 turkey 로 유사하게 구현
    	public void quack(){
    		turkey.gobble();
    	}
    	
    	// 칠면조는 오리처럼 멀리 못나니, 유사하게 구현
    	public void fly(){
    		for(int i = 0; i<5; i++){
    			turkey.fly();
    		}
    	}
    }
    ```
- 클라이언트는 호출 결과를 받긴 하지만, 중간에 어댑터가 있는 사실을 모르도록
### 어댑터 패턴의 정의
- 특정 클래스의 인터페이스를 클라이언트가 요구하는 다른 인터페이스로 변환해주는 **“래퍼(Wrapper)”**
- 구성(Composite)을 통해 래핑을 수행한다.
- 타깃 인터페이스
    - 어댑터가 목표로 하는 클라이언트가 요구하는 인터페이스
- 어댑터
    - 기존 클래스를 타깃 인터페이스 형태로 바꿔주는 래퍼
- 어댑티
    - 변환을 요구받는 기존 클래스.
![[Pasted image 20241212211450.png]]


### 어댑터 사용 시 주의사항
- 어댑터 구현은 타깃 인터페이스의 크기에 비례해서 복잡해짐
    - 대형 타깃 인터페이스 구현 시에는 그냥 모든 변경 사항을 캡슐화할 클래스 하나만 제공하기
- 반드시 하나의 어댑터 ↔ 하나의 클래스로 1대1 매칭되어서 감싸야 하는 것은 아님
    - Two-Way 어댑터를 통해 두개의 어댑터가 한개의 클래스를 감쌀 수도 있고
    - 하나의 타깃 인터페이스를 구현하려고 한 어댑터가 두개의 어댑티 클래스를 감싸야 하는 상황도 있을 수 있음
- 어댑터 구현 시 **기능 지원이 불가능**하다면?
    - 런타임 예외를 던지거나 ←추천
    - 문서화를 해두기

### 객체 어댑터 vs 클래스 어댑터
- 위 내용은 객체 어댑터.
- 클래스 어댑터라는 개념도 존재하나,
- 구성을 활용하는 객체 어댑터와는 달리
- 다중상속을 이용한 구현을 하기 때문에, 자바에선 잘 쓰이지 않음

### 데코레이터 패턴 vs 어댑터 패턴 vs 파사드 패턴
- 데코레이터 패턴 : wrapping을 수행함으로써 객체의 **행동과 책임을 확장**하고 싶을 때
- 어댑터 패턴 : wrapping을 수행함으로써 현재 감싸고 있는 인터페이스를 클라이언트의 **요청에 맞게 변환**
- 파사드 패턴 : wrapping 을 수행함으로써 현재 감싸고 있는 인터페이스들의 **기능의 사용을 단순하게 바꾸기**