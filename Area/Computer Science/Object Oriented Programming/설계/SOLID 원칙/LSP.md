## Liskov Substitution Principle, LSP
- 리스코브 치환의 원칙
- 서브 타입은 언제든 기반 타입으로 교체될 수 있어야 한다.
- 상속은 구현상속(extends 관계)이든 인터페이스 상속(implements 관계)이든 궁극적으로는 다형성을 통한 확장성 획득을 목표로 한다.
- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다
- 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요하다.
- 단순히 컴파일에 성공하는 것을 넘어서는 이야기
- 예) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반, 느리더라도 앞으로 가야함
- 적용방법
    1. 만약 두 개체가 똑 같은 일을 한다면 둘을 하나의 클래스로 표현하고 이들을 구분할 수 있는 필드를 둡니다.
    2. 똑같은 연산을 제공하지만, 이들을 약간씩 다르게 한다면 공통의 인터페이스를 만들고 둘이 이를 구현 합니다. (인터페이스 상속)
    3. 공통된 연산이 없다면 완전 별개인 2개의 클래스를 만듭니다.
    4. 만약 두 개체가 하는 일에 추가적으로 무언가를 더 한다면 구현 상속을 사용합니다.
- LSP를 이용해 변화에 닫혀있고, 확장에는 열려있게 만든다.
- 적용 이슈
    1. 혼동될 여지가 없고 트레이드 오프를 고려해 선택한 것이라면 그대로 둡니다.
    2. 다형성을 위한 상속 관계가 필요 없다면 Replace with Delegation을 합니다. 상속은 깨지기 쉬운 기반 클래스 등을 지니고 있으므로 IS-A관계가 성립되지 않습니다. LSP를 지키기 어렵다면 상속대신 합성(composition)을 사용하는 것이 좋습니다.
    - Replace with Delegation
        - 리팩토링 기술 중 하나.
        - 상속이 클래스 사이의 관계라면, 위임은 인스턴스 사이 관계.
        - 무분별한 상속을 막고 특정 인스턴스에만 위임함으로써, 소스코드 확장에 대처할 수 있도록 한다.
    - IS-A 관계, HAS-A 관계
        ### **IS-A 관계:**
        1. **정의**: 상속 또는 하위 클래스화라고도 알려진 IS-A 관계는 한 클래스가 다른 클래스의 유형임을 나타냅니다. 한 클래스(서브클래스)가 다른 클래스(슈퍼클래스)로부터 속성, 동작, 특성을 상속받는 관계를 나타냅니다.
        2. **구문**: Java 및 기타 여러 OOP 언어에서 IS-A 관계는 'extends' 키워드를 사용하여 설정됩니다. 예를 들어 **`class SubClass extends SuperClass {...}`**는 **`SubClass`** IS-A **`SuperClass`**를 의미합니다.
        3. **예**: 'Animal'이 슈퍼클래스이고 'Dog', 'Cat', 'Bird'가 하위 클래스인 클래스 계층 구조를 생각해 보세요. 우리는 말할 수있다:
            - **`개는 동물이다`**
            - **`고양이 IS-A 동물`**
            - **`새는 동물이다`**
        ### **HAS-A 관계:**
        1. **정의**: HAS-A 관계는 한 클래스에 다른 클래스가 파트 또는 멤버로 포함되어 있음을 나타냅니다. 이는 한 클래스가 속성이나 구성 요소 중 하나로 다른 클래스를 갖는 관계를 나타냅니다.
        2. **구현**: HAS-A 관계는 일반적으로 한 클래스의 객체가 다른 클래스 내에서 인스턴스화되는 합성을 사용하여 구현됩니다.
        3. **예**: 'Engine'이 있는 'Car' 클래스를 생각해 보세요. 우리는 말할 수있다:
            - **`자동차 HAS-A 엔진`**
            - **`엔진은 자동차의 일부이다`**
        ### **차이점:**
        1. **관계의 성격**:
            - IS-A: 상속관계를 기술합니다.
            - HAS-A: 포함 또는 구성의 관계를 설명합니다.
        2. **구문**:
            - IS-A: **`extends`** 키워드를 사용하여 설정됩니다.
            - HAS-A: 한 클래스를 다른 클래스 내에서 인스턴스화하여 구성됩니다.
        3. **목적**:
            - IS-A: 계층적 관계를 모델링하고 상속을 통해 코드 재사용을 용이하게 합니다.
            - HAS-A: 한 클래스가 다른 클래스로 구성되거나 다른 클래스를 일부로 포함하는 관계를 모델링하여 코드 구성 및 모듈성을 용이하게 합니다.
        4. **유연성**:
            - IS-A: 일반화-전문화 관계를 정의하는 방법을 제공합니다.
            - HAS-A: 다양한 구성요소를 결합하여 복잡한 객체를 구축할 수 있는 유연성을 제공합니다.
    - [[Association]]
        - 대표적인 HAS-A 관계 표현 기법.
        - 한 클래스가 다른 클래스에 포함될 때.
        - HAS-A 관계는 결합도를 높히지만, 어쩔 수 없다면 사용할 수밖에 없다.
    
    3. 상속 구조가 필요 하다면 Extract Subclass, Push Down Field, Push Down Method 등의 리팩토링 기법을 이용하여 LSP를 준수하는 상속 계층 구조를 구성 합니다.
    4. IS-A관계가 성립한다고 프로그램에서 까지 그런것은 아닙니다. 이들간의 관계 맺음은 이들의 역할과 이들 사이에 공유하는 연산이 있는지, 그리고 이들 연산이 어떻게 다른지 등을 종합적으로 검토 해 봐야 합니다.
    5. [[계약에 의한 설계]] 적용: 기반 클래스를 서브 클래스로 치환 가능하게 하려면 받아들이는 선 조건에서 서브 클래스의 제약사항이 기반 클래스의 제약 사항보다 느슨하거나 같아야 합니다. 만약 제약조건이 더 강하다면 기반 클래스에서 실행되던 것이 서브 클래스의 강 조건으로 인해 실행되지 않을 수도 있기 때문입니다. 반면 서브 클래스의 후 조건은 같거나 더 강해야 하는데, 약하다면 기반 클래스의 후 조건이 통과시키지 않는 상태를 통과시킬 수도 있기 때문입니다.
    
    - [[계약에 의한 설계]]
        - 서브 클래스에서는 기반 클래스의 사전 조건과 같거나 더 약한 수준에서 사전 조건을 대체할 수 있고,
        - 기반 클래스의 사후 조건과 같거나 더 강한 수준에서 사후 조건을 대체할 수 있다.
        - 필요조건과 충분조건의 관계